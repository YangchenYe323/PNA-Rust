use super::{Command, Response};
use crate::{KvsEngine, Result};
use futures::{SinkExt, StreamExt};
use tokio::net::{TcpListener, TcpStream, ToSocketAddrs};
use tokio_serde::formats::SymmetricalJson;
use tokio_serde::Framed;
use tokio_util::codec::{FramedRead, FramedWrite, LengthDelimitedCodec};
use tracing::{debug, error};

/// A KvServer that uses pluggable KvsEngine to store K-V pairs.
///
/// # Examples:
///
/// ```
/// use kvs_project_5::{
///     thread_pool::SharedQueueThreadPool,
///     KvStore,
///     KvServer,
///     KvClient,
///     Response,
/// };
/// use tempfile::TempDir;
///
/// #[tokio::main]
/// async fn main() {
///     let dir = TempDir::new().unwrap();
///     // opens a KvStore with the given working directory and 5 threads for concurrency
///     let kv = KvStore::<SharedQueueThreadPool>::open(dir.path(), 5).unwrap();
///     let server = KvServer::new(kv);
///
///     // start asynchrounous server in another tokio task
///     tokio::spawn(async move {
///         server.run("127.0.0.1:4000").await.unwrap();
///     });
///
///     // query the server
///     let mut cli = KvClient::connect("127.0.0.1:4000").await.unwrap();
///     assert_eq!(Response {
///         success: true,
///         message: "Key not found".to_string()    
///     },
///     cli.send_get("key".to_string()).await.unwrap()
///     );
///
///     cli.send_set("key".to_string(), "value".to_string()).await.unwrap();
///     assert_eq!(Response {
///         success: true,
///         message: "value".to_string()    
///     },
///     cli.send_get("key".to_string()).await.unwrap()
///     );
/// }
///
pub struct KvServer<T: KvsEngine> {
    store: T,
}

impl<T: KvsEngine> KvServer<T> {
    /// create a KvServer binded to addr
    ///
    /// # Error
    /// IoError generated by creating a TcpListener
    pub fn new(store: T) -> Self {
        Self { store }
    }

    /// Run the server
    pub async fn run(self, addr: impl ToSocketAddrs) -> Result<()> {
        let listener = TcpListener::bind(addr).await?;
        loop {
            let (socket, addr) = listener.accept().await?;
            debug!("Connected to Addr: {:?}", addr);
            let store = self.store.clone();
            // spawn a new async task that handles the connection
            tokio::spawn(async move {
                let result = serve(store, socket).await;
                if let Err(err) = result {
                    error!("Error handling connection: {}", err);
                }
            });
        }
    }
}

async fn serve<T: KvsEngine>(store: T, mut socket: TcpStream) -> Result<()> {
    let (read_half, write_half) = socket.split();

    let length_delimited = FramedRead::new(read_half, LengthDelimitedCodec::new());
    let mut deserialized: tokio_serde::Framed<_, Command, Command, _> =
        tokio_serde::SymmetricallyFramed::new(
            length_delimited,
            SymmetricalJson::<Command>::default(),
        );

    let length_delimited_write = FramedWrite::new(write_half, LengthDelimitedCodec::new());
    let mut serialized: Framed<_, Response, Response, _> = tokio_serde::SymmetricallyFramed::new(
        length_delimited_write,
        SymmetricalJson::<Response>::default(),
    );

    while let Some(msg) = deserialized.next().await {
        let msg = msg?;
        let response = match msg {
            Command::Get { key } => {
                // we must create a temporary binding so that a reference
                // to store will not be used across await point, since &T
                // is not Sync
                let res = store.get(key);
                let res = res.await;
                match res {
                    Ok(val) => Response::success(val.unwrap_or_else(|| "Key not found".to_owned())),

                    Err(error) => Response::failure(error.to_string()),
                }
            }

            Command::Set { key, val } => {
                let res = store.set(key, val);
                let res = res.await;
                match res {
                    Ok(_) => Response::success("".to_owned()),
                    Err(error) => Response::failure(error.to_string()),
                }
            }

            Command::Remove { key } => {
                let res = store.remove(key);
                let res = res.await;
                match res {
                    Ok(_) => Response::success("".to_owned()),
                    Err(error) => Response::failure(error.to_string()),
                }
            }
        };

        serialized.send(response).await?;
    }

    Ok(())
}
