use crate::{thread_pool::*, KvsEngine, Result};
use futures::{StreamExt, SinkExt};
use serde::{Deserialize, Serialize};
use tokio_serde::Framed;
use std::io::{BufReader, BufWriter};
use std::net::{SocketAddr};
use std::sync::atomic::{AtomicBool, Ordering};
use tracing::{debug, error};
use tokio::net::{TcpListener, TcpStream};
use tokio_serde::formats::SymmetricalJson;
use tokio_util::codec::{FramedRead, LengthDelimitedCodec, FramedWrite};

/// KvServer
pub struct KvServer<T: KvsEngine> {
    store: T,
}

impl<T: KvsEngine> KvServer<T> {
    /// create a KvServer binded to addr
    ///
    /// # Error
    /// IoError generated by creating a TcpListener
    pub fn new(store: T) -> Self {
        Self {
            store,
        }
    }

    /// Run the server
    #[tokio::main]
    pub async fn run(self, addr: SocketAddr) -> Result<()> {
        let listener = TcpListener::bind(addr).await?;
        loop {
            let (socket, _) = listener.accept().await?;
            let store = self.store.clone();
            tokio::spawn(async move {
                let result = serve(store, socket).await;
                if let Err(err) = result {
                    error!("Error handling connection: {}", err);
                }
            });
        }
    }

}

async fn serve<T: KvsEngine>(store: T, mut socket: TcpStream) -> Result<()> {
    let (read_half, write_half) = socket.split();

    let length_delimited = FramedRead::new(read_half, LengthDelimitedCodec::new());
    let mut deserialized: tokio_serde::Framed<_, Command, Command, _> = tokio_serde::SymmetricallyFramed::new(
        length_delimited,
        SymmetricalJson::<Command>::default(),
    );

    let length_delimited_write = FramedWrite::new(write_half, LengthDelimitedCodec::new());
    let mut serialized: Framed<_, Response, Response, _> = 
        tokio_serde::SymmetricallyFramed::new(
            length_delimited_write,
            SymmetricalJson::<Response>::default(),
        );
    
    while let Some(msg) = deserialized.next().await {
        let msg = msg?;
        let response = match msg {
            Command::Get { key } => {
                let res = store.get(key).await;
                match res {
                    Ok(val) => {
                        Response::success(val.unwrap_or("Key not found".to_owned()))
                    }

                    Err(error) => {
                        Response::failure(error.to_string())
                    }
                }
            }

            Command::Set { key, val } => {
                let res = store.set(key, val).await;
                match res {
                    Ok(_) => Response::success("".to_owned()),
                    Err(error) => Response::failure(error.to_string()),
                }
            }

            Command::Remove { key } => {
                let res = store.remove(key).await;
                match res {
                    Ok(_) => Response::success("".to_owned()),
                    Err(error) => Response::failure(error.to_string()),
                }
            }
        };

        serialized.send(response).await?;
    }

    Ok(())
}

/// Data structure to describe a use command
#[derive(Debug, Serialize, Deserialize)]
pub enum Command {
    /// get the string value of key
    Get {
        /// the string key
        key: String,
    },

    /// set the value of key
    Set {
        /// the string key
        key: String,
        /// the value
        val: String,
    },

    /// remove the value of key
    Remove {
        /// the string key
        key: String,
    },
}

/// Data structure to describe a server response
#[derive(Debug, Serialize, Deserialize)]
pub struct Response {
    /// flag indicating success or failure
    /// of operation
    pub success: bool,
    /// stores the result of operation
    pub message: String,
}

impl Response {
    fn success(message: String) -> Self {
        Self {
            success: true,
            message,
        }
    }

    fn failure(message: String) -> Self {
        Self {
            success: false,
            message,
        }
    }
}

async fn process_command<T: KvsEngine>(engine: T, command: Command) -> Response {
    match command {
        Command::Get { key } => process_get(engine, key).await,
        Command::Set { key, val } => process_set(engine, key, val).await,
        Command::Remove { key } => process_remove(engine, key).await,
    }
}

async fn process_get<T: KvsEngine>(engine: T, key: String) -> Response {
    let result = engine.get(key).await;
    match result {
        Ok(val) => Response::success(val.unwrap_or_else(|| String::from("Key not found"))),
        Err(error) => Response::failure(error.to_string()),
    }
}

async fn process_set<T: KvsEngine>(engine: T, key: String, val: String) -> Response {
    let result = engine.set(key, val).await;
    match result {
        Ok(_) => Response::success(String::new()),
        Err(error) => Response::failure(error.to_string()),
    }
}

async fn process_remove<T: KvsEngine>(engine: T, key: String) -> Response {
    let result = engine.remove(key).await;
    match result {
        Ok(_) => Response::success(String::new()),
        Err(error) => Response::failure(error.to_string()),
    }
}
