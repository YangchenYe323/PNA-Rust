use crate::{KvsEngine, Result};
use super::{Command, Response};
use serde_json::Deserializer;
use std::io::{BufReader, BufWriter, Write};
use std::net::{TcpListener, TcpStream, ToSocketAddrs};
use tracing::{debug, error};

/// A KvServer that uses pluggable KvsEngine to store K-V pairs.
/// 
/// # Examples:
/// 
/// ```
/// # use kvs_project_3::{KvsEngine, KvStore, KvServer, KvClient, Response};
/// # use tempfile::TempDir;
/// let dir = TempDir::new().unwrap();
/// let kv = Box::new(KvStore::open(dir.path()).unwrap());
/// // start a server binded to '127.0.0.1:4000' and use a KvStore as storage engine
/// let server = KvServer::new("127.0.0.1:4000", kv).unwrap(); 
/// 
pub struct KvServer {
    listener: TcpListener,
    store: Box<dyn KvsEngine>,
}

impl KvServer {
    /// create a KvServer binded to addr
    ///
    /// # Error
    /// IoError generated by [creating a TcpListener](TcpListener::bind)
    pub fn new(addr: impl ToSocketAddrs, store: Box<dyn KvsEngine>) -> Result<Self> {
        let listener = TcpListener::bind(addr)?;

        Ok(KvServer { listener, store })
    }

    /// Run the server in an infinite loop
    pub fn run(mut self) {
        loop {
            let result = self.process_connection();
            if let Err(error) = result {
                // the error we catch here are errors
                // related to network that cause the failure
                // of a communication
                // errors occured from storage layer are
                // sent to client in response
                error!("Error occured: {}", error);
            }
        }
    }

    fn process_connection(&mut self) -> Result<()> {
        let (stream, _) = self.listener.accept()?;
        debug!("Accepted connection: {:?}", &stream);

        self.handle_connection(stream)?;
        Ok(())
    }

    fn handle_connection(&mut self, stream: TcpStream) -> Result<()> {
        let reader = BufReader::new(&stream);
        let mut writer = BufWriter::new(&stream);
        // interpret the stream as a sequence of Command types
        let command_reader = Deserializer::from_reader(reader);   
        for command in command_reader.into_iter() {
            // deserialize
            let command = command?;
            let response = self.process_command(command);

            // write response
            let response_bytes = serde_json::to_vec(&response)?;
            writer.write_all(&response_bytes[..])?;
            writer.flush()?;
        }
        Ok(())
    }

    fn process_command(&mut self, command: Command) -> Response {
        match command {
            Command::Get { key } => self.process_get(key),
            Command::Set { key, val } => self.process_set(key, val),
            Command::Remove { key } => self.process_remove(key),
        }
    }

    fn process_get(&mut self, key: String) -> Response {
        let result = self.store.get(key);
        match result {
            Ok(val) => Response::success(val.unwrap_or_else(|| String::from("Key not found"))),
            Err(error) => Response::failure(error.to_string()),
        }
    }

    fn process_set(&mut self, key: String, val: String) -> Response {
        let result = self.store.set(key, val);
        match result {
            Ok(_) => Response::success(String::new()),
            Err(error) => Response::failure(error.to_string()),
        }
    }

    fn process_remove(&mut self, key: String) -> Response {
        let result = self.store.remove(key);
        match result {
            Ok(_) => Response::success(String::new()),
            Err(error) => Response::failure(error.to_string()),
        }
    }
}
