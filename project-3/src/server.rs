use std::net::{ ToSocketAddrs, TcpListener, TcpStream };
use std::io::prelude::*;
use std::io::{ BufReader, BufWriter, Cursor };
use tracing::debug;
use serde::{Deserialize, Serialize};
use serde_json::Deserializer;
use byteorder::{ WriteBytesExt, ReadBytesExt, NetworkEndian };
use crate::Result;
use super::protocol;

/// KvServer
pub struct KvServer {
	listener: TcpListener,
}

impl KvServer {
	/// create a KvServer binded to addr
	/// 
	/// # Error
	/// IoError generated by creating a TcpListener
	pub fn new(addr: impl ToSocketAddrs) -> Result<KvServer> {
		let listener = TcpListener::bind(addr)?;

		Ok(KvServer {
			listener
		})
	}

	/// Run the server
	pub fn run(mut self) -> Result<()>{
		loop {
			let (stream, _) = self.listener.accept()?;
			self.handle_connection(stream)?;
		}
	}

	fn handle_connection(&mut self, mut stream: TcpStream) -> Result<()> {
		debug!("Accepted connection: {:?}", &stream);

		let mut reader = BufReader::new(&stream);
		let mut writer = BufWriter::new(&stream);

		let command: Command = protocol::read(reader)?;

		// generate response by querying storage engine
		// mock it for now
		let response = Response {
			success: true,
			message: String::from("Hello"),
		};

		protocol::write(writer, response)?;

		Ok(())
	}

}

/// Data structure to describe a use command
#[derive(Debug, Serialize, Deserialize)]
pub enum Command {
	/// get the string value of key
	Get {
		/// the string key
		key: String,
	},

	/// set the value of key
	Set {
		/// the string key
		key: String,
		/// the value
		val: String,
	},

	/// remove the value of key
	Remove {
		/// the string key
		key: String,
	},
}

/// Data structure to describe a server response
#[derive(Debug, Serialize, Deserialize)]
pub struct Response {
	/// flag indicating success or failure
	/// of operation
	success: bool,
	/// stores the result of operation
	message: String,
}
