use super::protocol;
use crate::{KvsEngine, Result};
use serde::{Deserialize, Serialize};
use std::io::{BufReader, BufWriter};
use std::net::{TcpListener, TcpStream, ToSocketAddrs};
use tracing::{debug, error};

/// KvServer
pub struct KvServer {
    listener: TcpListener,
    store: Box<dyn KvsEngine>,
}

impl KvServer {
    /// create a KvServer binded to addr
    ///
    /// # Error
    /// IoError generated by creating a TcpListener
    pub fn new(addr: impl ToSocketAddrs, store: Box<dyn KvsEngine>) -> Result<Self> {
        let listener = TcpListener::bind(addr)?;

        Ok(KvServer { listener, store })
    }

    /// Run the server
    pub fn run(mut self) {
        loop {
            let result = self.process_connection();
            if let Err(error) = result {
                // the error we catch here are errors
                // related to network that cause the failure
                // of a communication
                // errors occured from storage layer are
                // sent to client in response
                error!("Error occured: {}", error);
            }
        }
    }

    fn process_connection(&mut self) -> Result<()> {
        let (stream, _) = self.listener.accept()?;
        debug!("Accepted connection: {:?}", &stream);

        self.handle_connection(stream)?;
        Ok(())
    }

    fn handle_connection(&mut self, stream: TcpStream) -> Result<()> {
        let reader = BufReader::new(&stream);
        let writer = BufWriter::new(&stream);

        let command: Command = protocol::read(reader)?;

        let response = self.process_command(command);

        protocol::write(writer, response)?;

        Ok(())
    }

    fn process_command(&mut self, command: Command) -> Response {
        match command {
            Command::Get { key } => self.process_get(key),
            Command::Set { key, val } => self.process_set(key, val),
            Command::Remove { key } => self.process_remove(key),
        }
    }

    fn process_get(&mut self, key: String) -> Response {
        let result = self.store.get(key);
        match result {
            Ok(val) => Response::success(val.unwrap_or_else(|| String::from("Key not found"))),
            Err(error) => Response::failure(error.to_string()),
        }
    }

    fn process_set(&mut self, key: String, val: String) -> Response {
        let result = self.store.set(key, val);
        match result {
            Ok(_) => Response::success(String::new()),
            Err(error) => Response::failure(error.to_string()),
        }
    }

    fn process_remove(&mut self, key: String) -> Response {
        let result = self.store.remove(key);
        match result {
            Ok(_) => Response::success(String::new()),
            Err(error) => Response::failure(error.to_string()),
        }
    }
}

/// Data structure to describe a use command
#[derive(Debug, Serialize, Deserialize)]
pub enum Command {
    /// get the string value of key
    Get {
        /// the string key
        key: String,
    },

    /// set the value of key
    Set {
        /// the string key
        key: String,
        /// the value
        val: String,
    },

    /// remove the value of key
    Remove {
        /// the string key
        key: String,
    },
}

/// Data structure to describe a server response
#[derive(Debug, Serialize, Deserialize)]
pub struct Response {
    /// flag indicating success or failure
    /// of operation
    pub success: bool,
    /// stores the result of operation
    pub message: String,
}

impl Response {
    fn success(message: String) -> Self {
        Self {
            success: true,
            message,
        }
    }

    fn failure(message: String) -> Self {
        Self {
            success: false,
            message,
        }
    }
}
