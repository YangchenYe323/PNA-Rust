use super::protocol;
use crate::{thread_pool::*, KvsEngine, Result};
use serde::{Deserialize, Serialize};
use std::io::{BufReader, BufWriter};
use std::net::{TcpListener, TcpStream, ToSocketAddrs};
use tracing::{debug, error};

/// KvServer
pub struct KvServer<T: KvsEngine, P: ThreadPool> {
    listener: TcpListener,
    store: T,
    pool: P,
}

impl<T: KvsEngine, P: ThreadPool> KvServer<T, P> {
    /// create a KvServer binded to addr
    ///
    /// # Error
    /// IoError generated by creating a TcpListener
    pub fn new(addr: impl ToSocketAddrs, store: T, pool: P) -> Result<Self> {
        let listener = TcpListener::bind(addr)?;

        Ok(KvServer {
            listener,
            store,
            pool,
        })
    }

    /// Run the server
    pub fn run(self) {
        loop {
            let stream = self.receive_connection();
            match stream {
                Ok(stream) => {
                    let kv = self.store.clone();
                    self.pool.spawn(move || {
                        let result = process_connection(kv, stream);
                        if let Err(error) = result {
                            // this is error during reading and sending messages
                            // across the network
                            error!("Communication Failed: {}", error);
                        }
                    })
                }
                // this is error during connection
                Err(err) => error!("Connection Failed: {}", err),
            }
        }
    }

    fn receive_connection(&self) -> Result<TcpStream> {
        let (stream, _) = self.listener.accept()?;
        debug!("Accepted connection: {:?}", &stream);
        Ok(stream)
    }
}

/// Data structure to describe a use command
#[derive(Debug, Serialize, Deserialize)]
pub enum Command {
    /// get the string value of key
    Get {
        /// the string key
        key: String,
    },

    /// set the value of key
    Set {
        /// the string key
        key: String,
        /// the value
        val: String,
    },

    /// remove the value of key
    Remove {
        /// the string key
        key: String,
    },
}

/// Data structure to describe a server response
#[derive(Debug, Serialize, Deserialize)]
pub struct Response {
    /// flag indicating success or failure
    /// of operation
    pub success: bool,
    /// stores the result of operation
    pub message: String,
}

impl Response {
    fn success(message: String) -> Self {
        Self {
            success: true,
            message,
        }
    }

    fn failure(message: String) -> Self {
        Self {
            success: false,
            message,
        }
    }
}

fn process_connection<T: KvsEngine>(engine: T, stream: TcpStream) -> Result<()> {
    let reader = BufReader::new(&stream);
    let writer = BufWriter::new(&stream);

    let command: Command = protocol::read(reader)?;

    let response = process_command(&engine, command);

    protocol::write(writer, response)?;

    Ok(())
}

fn process_command<T: KvsEngine>(engine: &T, command: Command) -> Response {
    match command {
        Command::Get { key } => process_get(engine, key),
        Command::Set { key, val } => process_set(engine, key, val),
        Command::Remove { key } => process_remove(engine, key),
    }
}

fn process_get<T: KvsEngine>(engine: &T, key: String) -> Response {
    let result = engine.get(key);
    match result {
        Ok(val) => Response::success(val.unwrap_or_else(|| String::from("Key not found"))),
        Err(error) => Response::failure(error.to_string()),
    }
}

fn process_set<T: KvsEngine>(engine: &T, key: String, val: String) -> Response {
    let result = engine.set(key, val);
    match result {
        Ok(_) => Response::success(String::new()),
        Err(error) => Response::failure(error.to_string()),
    }
}

fn process_remove<T: KvsEngine>(engine: &T, key: String) -> Response {
    let result = engine.remove(key);
    match result {
        Ok(_) => Response::success(String::new()),
        Err(error) => Response::failure(error.to_string()),
    }
}
