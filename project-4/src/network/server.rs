use super::protocol;
use crate::{thread_pool::*, KvsEngine, Result};
use serde::{Deserialize, Serialize};
use std::io::{BufReader, BufWriter};
use std::net::{TcpListener, TcpStream, ToSocketAddrs};
use std::sync::{Arc, Mutex};
use tracing::{debug, error};

/// KvServer
pub struct KvServer<T: KvsEngine, P: ThreadPool> {
    listener: TcpListener,
    store: T,
    pool: P,
    shutdown: Arc<Mutex<bool>>,
}

impl<T: KvsEngine, P: ThreadPool> KvServer<T, P> {
    /// create a KvServer binded to addr
    ///
    /// # Error
    /// IoError generated by creating a TcpListener
    pub fn new(addr: impl ToSocketAddrs, store: T, pool: P) -> Result<Self> {
        let listener = TcpListener::bind(addr)?;

        // set to non-blocking so that we can close
        // it programmatically
        // listener.set_nonblocking(true).expect("Cannot Set Non Blocking");

        Ok(KvServer {
            listener,
            store,
            pool,
            shutdown: Arc::new(Mutex::new(false)),
        })
    }

    /// Run the server
    pub fn run(self) {
        while self.not_terminated() {
            // this ? operator will catch the situation of termination
            let stream = self.receive_connection();
            match stream {
                Ok(stream) => {
                    let kv = self.store.clone();
                    self.pool.spawn(move || {
                        let result = process_connection(kv, stream);
                        if let Err(error) = result {
                            // this is error during reading and sending messages
                            // across the network
                            error!("Communication Failed: {}", error);
                        }
                    })
                }
                // this is error during connection
                Err(err) => {
                    error!("{}", err);
                }
            }
        }
    }

    fn receive_connection(&self) -> Result<TcpStream> {
        let (stream, _) = self.listener.accept()?;
        debug!("Received Connection: {:?}", stream);
        Ok(stream)
    }

    /// shutdown the server
    /// calling run function after shutdown
    /// will have no effect. If run function is
    /// running on the other thread, it will terminate
    /// gracefully after serving last request
    pub fn terminate(&self) {
        let mut shutdown_ref = self.shutdown.lock().unwrap();
        *shutdown_ref = true;
    }

    /// This method is intended for testing purpose only
    /// handing out the shutdown handle of the server so that
    /// other programmng thread can shutdown the server by accessing
    /// the handle
    pub fn terinate_handle(&self) -> Arc<Mutex<bool>> {
        Arc::clone(&self.shutdown)
    }

    fn not_terminated(&self) -> bool {
        let guard = self.shutdown.lock().unwrap();
        if *guard {
            false
        } else {
            true
        }
    }
}

/// Data structure to describe a use command
#[derive(Debug, Serialize, Deserialize)]
pub enum Command {
    /// get the string value of key
    Get {
        /// the string key
        key: String,
    },

    /// set the value of key
    Set {
        /// the string key
        key: String,
        /// the value
        val: String,
    },

    /// remove the value of key
    Remove {
        /// the string key
        key: String,
    },
}

/// Data structure to describe a server response
#[derive(Debug, Serialize, Deserialize)]
pub struct Response {
    /// flag indicating success or failure
    /// of operation
    pub success: bool,
    /// stores the result of operation
    pub message: String,
}

impl Response {
    fn success(message: String) -> Self {
        Self {
            success: true,
            message,
        }
    }

    fn failure(message: String) -> Self {
        Self {
            success: false,
            message,
        }
    }
}

fn process_connection<T: KvsEngine>(engine: T, stream: TcpStream) -> Result<()> {
    let mut reader = BufReader::new(&stream);
    let mut writer = BufWriter::new(&stream);

    loop {
        let command: Command = protocol::read(&mut reader)?;

        let response = process_command(&engine, command);

        protocol::write(&mut writer, response)?;
    }
}

fn process_command<T: KvsEngine>(engine: &T, command: Command) -> Response {
    match command {
        Command::Get { key } => process_get(engine, key),
        Command::Set { key, val } => process_set(engine, key, val),
        Command::Remove { key } => process_remove(engine, key),
    }
}

fn process_get<T: KvsEngine>(engine: &T, key: String) -> Response {
    let result = engine.get(key);
    match result {
        Ok(val) => Response::success(val.unwrap_or_else(|| String::from("Key not found"))),
        Err(error) => Response::failure(error.to_string()),
    }
}

fn process_set<T: KvsEngine>(engine: &T, key: String, val: String) -> Response {
    let result = engine.set(key, val);
    match result {
        Ok(_) => Response::success(String::new()),
        Err(error) => Response::failure(error.to_string()),
    }
}

fn process_remove<T: KvsEngine>(engine: &T, key: String) -> Response {
    let result = engine.remove(key);
    match result {
        Ok(_) => Response::success(String::new()),
        Err(error) => Response::failure(error.to_string()),
    }
}
