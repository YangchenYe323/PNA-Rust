use super::{Command, Response};
use crate::{thread_pool::*, KvsEngine, Result};
use serde_json::Deserializer;
use std::io::{BufReader, BufWriter, Write};
use std::net::{TcpListener, TcpStream, ToSocketAddrs};
use std::sync::{Arc, Mutex};
use tracing::{debug, error};

/// A KvServer that uses pluggable KvsEngine to store K-V pairs.
///
/// # Examples:
///
/// ```
/// use kvs_project_4::{
///     thread_pool::*,
///     KvsEngine,
///     KvStore,
///     KvServer,
///     KvClient,
///     Response,
/// };
/// use tempfile::TempDir;
/// use std::thread;
///
/// let dir = TempDir::new().unwrap();
/// let kv = KvStore::open(dir.path()).unwrap();
/// let pool = SharedQueueThreadPool::new(5).unwrap();
/// // start a server binded to '127.0.0.1:4000', uses a KvStore as storage engine and use the given thread pool
/// // for concurrency
/// let server = KvServer::new("127.0.0.1:4000", kv, pool).unwrap();
/// // run server in another thread to simulate a real server;
/// thread::spawn(move || {
///     server.run();
/// });
///
/// // query the server
/// let mut cli = KvClient::new("127.0.0.1:4000").unwrap();
/// assert_eq!(
///     Response {
///         success: true,
///         message: "Key not found".to_string(),
///     },
///     cli.send_get("key".to_string()).unwrap()
/// )
///
///
pub struct KvServer<T: KvsEngine, P: ThreadPool> {
    listener: TcpListener,
    store: T,
    pool: P,
    shutdown: Arc<Mutex<bool>>,
}

impl<T: KvsEngine, P: ThreadPool> KvServer<T, P> {
    /// create a KvServer binded to addr
    ///
    /// # Error
    /// IoError generated by creating a TcpListener
    pub fn new(addr: impl ToSocketAddrs, store: T, pool: P) -> Result<Self> {
        let listener = TcpListener::bind(addr)?;

        // set to non-blocking so that we can close
        // it programmatically
        // listener.set_nonblocking(true).expect("Cannot Set Non Blocking");

        Ok(KvServer {
            listener,
            store,
            pool,
            shutdown: Arc::new(Mutex::new(false)),
        })
    }

    /// Run the server
    pub fn run(self) {
        while self.not_terminated() {
            let stream = self.receive_connection();
            match stream {
                Ok(stream) => {
                    let kv = self.store.clone();
                    self.pool.spawn(move || {
                        let result = process_connection(kv, stream);
                        if let Err(error) = result {
                            // this is error during reading and sending messages
                            // across the network
                            error!("Communication Failed: {}", error);
                        }
                    })
                }
                // this is error during connection
                Err(err) => {
                    error!("{}", err);
                }
            }
        }
    }

    fn receive_connection(&self) -> Result<TcpStream> {
        let (stream, _) = self.listener.accept()?;
        debug!("Received Connection: {:?}", stream);
        Ok(stream)
    }

    /// shutdown the server
    /// calling run function after shutdown
    /// will have no effect. If run function is
    /// running on the other thread, it will terminate
    /// gracefully after serving last request
    pub fn terminate(&self) {
        let mut shutdown_ref = self.shutdown.lock().unwrap();
        *shutdown_ref = true;
    }

    /// Handing out the shutdown handle of the server so that
    /// other programmng thread can shutdown the server by accessing
    /// the handle
    ///
    pub fn terinate_handle(&self) -> Arc<Mutex<bool>> {
        Arc::clone(&self.shutdown)
    }

    fn not_terminated(&self) -> bool {
        let guard = self.shutdown.lock().unwrap();
        !(*guard)
    }
}

fn process_connection<T: KvsEngine>(engine: T, stream: TcpStream) -> Result<()> {
    let reader = BufReader::new(&stream);
    let mut writer = BufWriter::new(&stream);
    // interpret the stream as a sequence of Command types
    let command_reader = Deserializer::from_reader(reader);
    for command in command_reader.into_iter() {
        // deserialize
        let command = command?;
        let response = process_command(&engine, command);

        // write response
        let response_bytes = serde_json::to_vec(&response)?;
        writer.write_all(&response_bytes[..])?;
        writer.flush()?;
    }
    Ok(())
}

fn process_command<T: KvsEngine>(engine: &T, command: Command) -> Response {
    match command {
        Command::Get { key } => process_get(engine, key),
        Command::Set { key, val } => process_set(engine, key, val),
        Command::Remove { key } => process_remove(engine, key),
    }
}

fn process_get<T: KvsEngine>(engine: &T, key: String) -> Response {
    let result = engine.get(key);
    match result {
        Ok(val) => Response::success(val.unwrap_or_else(|| String::from("Key not found"))),
        Err(error) => Response::failure(error.to_string()),
    }
}

fn process_set<T: KvsEngine>(engine: &T, key: String, val: String) -> Response {
    let result = engine.set(key, val);
    match result {
        Ok(_) => Response::success(String::new()),
        Err(error) => Response::failure(error.to_string()),
    }
}

fn process_remove<T: KvsEngine>(engine: &T, key: String) -> Response {
    let result = engine.remove(key);
    match result {
        Ok(_) => Response::success(String::new()),
        Err(error) => Response::failure(error.to_string()),
    }
}
